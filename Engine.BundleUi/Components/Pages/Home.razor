@page "/"
@implements IDisposable
@using Engine.BundleUi.Models
@using Engine.BundleUi.Services
@using System.Text.Json.Nodes
@inject BundleApiClient BundleApiClient

<PageTitle>Bundle Studio</PageTitle>

<div class="studio-shell">
    <section class="hero">
        <h1>Workflow Bundle Studio</h1>
        <p>Upload a workflow bundle ZIP, preview the workflow + scripts + execution plan, then register it.</p>
    </section>

    <section class="panel">
        <div class="panel-header">
            <h2>Registered Workflows</h2>
            <button class="btn-secondary" @onclick="RefreshWorkflowsAsync" disabled="@IsLoadingWorkflows">Refresh</button>
        </div>

        @if (!string.IsNullOrWhiteSpace(WorkflowsErrorMessage))
        {
            <div class="alert error">@WorkflowsErrorMessage</div>
        }
        else if (RegisteredWorkflows.Count == 0)
        {
            <p>No workflows registered yet.</p>
        }
        else
        {
            <div class="table-wrap">
                <table>
                    <thead>
                    <tr>
                        <th>Name</th>
                        <th>Version</th>
                        <th>Registered</th>
                    </tr>
                    </thead>
                    <tbody>
                    @foreach (var workflow in RegisteredWorkflows)
                    {
                        <tr>
                            <td><strong>@workflow.Name</strong></td>
                            <td>@workflow.Version</td>
                            <td>@workflow.RegisteredAt.LocalDateTime</td>
                        </tr>
                    }
                    </tbody>
                </table>
            </div>
        }
    </section>

    <section class="panel">
        <div class="panel-header">
            <h2>Execute Workflow</h2>
            @if (IsWatchingInstance)
            {
                <button class="btn-secondary" @onclick="StopWatching">Stop Watching</button>
            }
        </div>

        <div class="field-row">
            <label for="workflowSelect">Workflow Version</label>
            <select id="workflowSelect" @bind="SelectedWorkflowIndex" disabled="@(IsBusy || RegisteredWorkflows.Count == 0)">
                @if (RegisteredWorkflows.Count == 0)
                {
                    <option value="-1">No workflows available</option>
                }
                else
                {
                    @for (var i = 0; i < RegisteredWorkflows.Count; i++)
                    {
                        var workflow = RegisteredWorkflows[i];
                        <option value="@i">@workflow.Name v@workflow.Version</option>
                    }
                }
            </select>
        </div>

        <div class="field-row">
            <label for="inputsJson">Inputs (JSON object)</label>
            <textarea
                id="inputsJson"
                class="json-input"
                @bind="WorkflowInputsJson"
                disabled="@IsBusy"></textarea>
        </div>

        <div class="actions">
            <button class="btn-primary" @onclick="ExecuteWorkflowAsync" disabled="@(IsBusy || SelectedWorkflowIndex < 0)">Start Workflow</button>
            @if (CurrentInstance is not null)
            {
                <button class="btn-secondary" @onclick="RefreshCurrentInstanceAsync" disabled="@IsBusy">Refresh Progress</button>
                @if (!IsTerminalStatus(CurrentInstance.Status))
                {
                    <button class="btn-danger" @onclick="CancelCurrentInstanceAsync" disabled="@IsBusy">Stop Workflow</button>
                }
            }
        </div>

        @if (!string.IsNullOrWhiteSpace(ExecutionErrorMessage))
        {
            <div class="alert error">@ExecutionErrorMessage</div>
        }

        @if (!string.IsNullOrWhiteSpace(ExecutionSuccessMessage))
        {
            <div class="alert success">@ExecutionSuccessMessage</div>
        }

        @if (CurrentInstance is not null)
        {
            <div class="instance-meta">
                <div class="meta-line">Instance: <code>@CurrentInstance.InstanceId</code></div>
                <div class="meta-line">Workflow: <strong>@($"{CurrentInstance.WorkflowName} v{CurrentInstance.WorkflowVersion}")</strong></div>
                <div class="meta-line">Status: <span class="status-pill @StatusClass(CurrentInstance.Status)">@CurrentInstance.Status</span></div>
                <div class="meta-line">Updated: <strong>@CurrentInstance.UpdatedAt.LocalDateTime</strong></div>
            </div>

            <div class="table-wrap">
                <table>
                    <thead>
                    <tr>
                        <th>Step</th>
                        <th>Status</th>
                        <th>Attempt</th>
                        <th>Started</th>
                        <th>Finished</th>
                        <th>Blocked By</th>
                        <th>Error</th>
                    </tr>
                    </thead>
                    <tbody>
                    @foreach (var step in CurrentInstance.Steps)
                    {
                        <tr>
                            <td>
                                <div class="step-name">@step.DisplayName</div>
                                <code>@step.StepId</code>
                            </td>
                            <td><span class="status-pill @StatusClass(step.Status)">@step.Status</span></td>
                            <td>@step.Attempt</td>
                            <td>@(step.StartedAt?.LocalDateTime.ToString() ?? "-")</td>
                            <td>@(step.FinishedAt?.LocalDateTime.ToString() ?? "-")</td>
                            <td>@(step.BlockedBy.Count == 0 ? "-" : string.Join(", ", step.BlockedBy))</td>
                            <td>@(string.IsNullOrWhiteSpace(step.LastError) ? "-" : step.LastError)</td>
                        </tr>
                    }
                    </tbody>
                </table>
            </div>

        }
    </section>

    <section class="panel upload-panel">
        <div class="field-row">
            <label for="bundleInput">Bundle ZIP</label>
            <InputFile id="bundleInput" OnChange="OnFileSelected" accept=".zip" />
        </div>

        @if (SelectedFile is not null)
        {
            <div class="selected-file">Selected: <strong>@SelectedFile.Name</strong> (@FormatBytes(SelectedFile.Size))</div>
        }

        <div class="actions">
            <button class="btn-primary" @onclick="PreviewAsync" disabled="@(IsBusy || SelectedFile is null)">Preview Bundle</button>
            @if (Preview is not null && Preview.CanRegister && Registration is null)
            {
                <button class="btn-accent" @onclick="RegisterAsync" disabled="@IsBusy">Register Bundle</button>
            }
        </div>

        @if (!string.IsNullOrWhiteSpace(ErrorMessage))
        {
            <div class="alert error">@ErrorMessage</div>
        }

        @if (!string.IsNullOrWhiteSpace(SuccessMessage))
        {
            <div class="alert success">@SuccessMessage</div>
        }
    </section>

    @if (Preview is not null)
    {
        <section class="panel metadata-grid">
            <div>
                <h2>@Preview.WorkflowName</h2>
                <div class="meta-line">Version: <strong>@Preview.WorkflowVersion</strong></div>
                <div class="meta-line">Bundle file: <strong>@Preview.BundleFileName</strong></div>
                <div class="meta-line">Preview ID: <code>@Preview.PreviewId</code></div>
                <div class="meta-line">Expires: <strong>@Preview.ExpiresAt.LocalDateTime</strong></div>
            </div>
            <div>
                <h3>Description</h3>
                <p>@(string.IsNullOrWhiteSpace(Preview.WorkflowDescription) ? "(none)" : Preview.WorkflowDescription)</p>
                <h3>Details</h3>
                <p>@(string.IsNullOrWhiteSpace(Preview.WorkflowDetails) ? "(none)" : Preview.WorkflowDetails)</p>
            </div>
        </section>

        @if (Preview.ValidationErrors.Count > 0)
        {
            <section class="panel">
                <h2>Validation Errors</h2>
                <ul class="error-list">
                    @foreach (var error in Preview.ValidationErrors)
                    {
                        <li>@error</li>
                    }
                </ul>
            </section>
        }

        <section class="panel">
            <h2>Steps</h2>
            <div class="table-wrap">
                <table>
                    <thead>
                    <tr>
                        <th>Step</th>
                        <th>Type</th>
                        <th>Activity Ref</th>
                        <th>Resolved Script</th>
                        <th>Depends On</th>
                    </tr>
                    </thead>
                    <tbody>
                    @foreach (var step in Preview.Steps)
                    {
                        <tr>
                            <td>
                                <div class="step-name">@step.DisplayName</div>
                                <code>@step.StepId</code>
                            </td>
                            <td>@(step.IsWaitStep ? $"Wait ({step.EventType})" : "Activity")</td>
                            <td><code>@step.ActivityRef</code></td>
                            <td>
                                @if (step.ResolvedScriptPath is null)
                                {
                                    <span>-</span>
                                }
                                else
                                {
                                    <span class="@(step.ScriptExists ? "ok" : "missing")">@step.ResolvedScriptPath</span>
                                }
                            </td>
                            <td>
                                @if (step.DependsOn.Count == 0)
                                {
                                    <span>-</span>
                                }
                                else
                                {
                                    <span>@string.Join(", ", step.DependsOn)</span>
                                }
                            </td>
                        </tr>
                    }
                    </tbody>
                </table>
            </div>
        </section>

        <section class="panel split-panel">
            <div>
                <h2>Files</h2>
                <div class="file-list">
                    @foreach (var file in Preview.Files)
                    {
                        <div><code>@file</code></div>
                    }
                </div>
            </div>
            <div>
                <h2>Execution Plan</h2>
                @if (Preview.ExecutionPlan.Count == 0)
                {
                    <p>No plan available (workflow validation failed).</p>
                }
                else
                {
                    @foreach (var stage in Preview.ExecutionPlan)
                    {
                        <div class="stage">
                            <div class="stage-label">Stage @stage.StageNumber</div>
                            <div class="chips">
                                @foreach (var stepId in stage.StepIds)
                                {
                                    <span class="chip">@stepId</span>
                                }
                            </div>
                        </div>
                    }
                }
            </div>
        </section>
    }
</div>

@code {
    private IBrowserFile? SelectedFile { get; set; }

    private BundlePreviewResponse? Preview { get; set; }

    private BundleRegisterResponse? Registration { get; set; }

    private IReadOnlyList<WorkflowDefinitionMetadata> RegisteredWorkflows { get; set; } = [];

    private WorkflowInstanceChecklist? CurrentInstance { get; set; }

    private string WorkflowInputsJson { get; set; } = "{}";

    private int SelectedWorkflowIndex { get; set; } = -1;

    private bool IsBusy { get; set; }

    private bool IsLoadingWorkflows { get; set; }

    private bool IsWatchingInstance { get; set; }

    private string? ErrorMessage { get; set; }

    private string? WorkflowsErrorMessage { get; set; }

    private string? ExecutionErrorMessage { get; set; }

    private string? ExecutionSuccessMessage { get; set; }

    private string? SuccessMessage { get; set; }

    private CancellationTokenSource? _watchCancellationSource;

    protected override async Task OnInitializedAsync()
    {
        await RefreshWorkflowsAsync();
    }

    public void Dispose()
    {
        StopWatching();
    }

    private void OnFileSelected(InputFileChangeEventArgs eventArgs)
    {
        SelectedFile = eventArgs.FileCount > 0 ? eventArgs.File : null;
        Preview = null;
        Registration = null;
        ErrorMessage = null;
        SuccessMessage = null;
    }

    private async Task PreviewAsync()
    {
        if (SelectedFile is null)
        {
            return;
        }

        await RunBusyAsync(async cancellationToken =>
        {
            Preview = await BundleApiClient.PreviewBundleAsync(SelectedFile, cancellationToken);
            Registration = null;
            SuccessMessage = Preview.CanRegister
                ? "Preview generated. Bundle is valid and ready to register."
                : "Preview generated with validation errors. Resolve issues before registration.";
        });
    }

    private async Task RegisterAsync()
    {
        if (Preview is null)
        {
            return;
        }

        await RunBusyAsync(async cancellationToken =>
        {
            Registration = await BundleApiClient.RegisterPreviewAsync(Preview.PreviewId, cancellationToken);
            await RefreshWorkflowsAsync();
            SuccessMessage =
                $"Registered bundle {Registration.BundleId} as workflow {Registration.WorkflowName} v{Registration.WorkflowVersion}.";
            ErrorMessage = null;
        });
    }

    private async Task RunBusyAsync(Func<CancellationToken, Task> action)
    {
        ErrorMessage = null;
        IsBusy = true;

        using var cancellationSource = new CancellationTokenSource();
        try
        {
            await action(cancellationSource.Token);
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
            SuccessMessage = null;
        }
        finally
        {
            IsBusy = false;
        }
    }

    private async Task ExecuteWorkflowAsync()
    {
        var selected = GetSelectedWorkflow();
        if (selected is null)
        {
            ExecutionErrorMessage = "Select a workflow version to execute.";
            return;
        }

        await RunBusyAsync(async cancellationToken =>
        {
            var inputsNode = JsonNode.Parse(WorkflowInputsJson);
            if (inputsNode is not JsonObject inputsObject)
            {
                throw new InvalidOperationException("Inputs must be a valid JSON object.");
            }

            CurrentInstance = await BundleApiClient.StartWorkflowInstanceAsync(
                selected.Name,
                inputsObject,
                selected.Version,
                cancellationToken);

            ExecutionErrorMessage = null;
            ExecutionSuccessMessage = $"Started workflow instance {CurrentInstance.InstanceId}.";
            StartWatching(CurrentInstance.InstanceId);
        });
    }

    private async Task RefreshCurrentInstanceAsync()
    {
        if (CurrentInstance is null)
        {
            return;
        }

        await RunBusyAsync(async cancellationToken =>
        {
            CurrentInstance = await BundleApiClient.GetWorkflowInstanceAsync(CurrentInstance.InstanceId, cancellationToken);
            ExecutionErrorMessage = null;
        });
    }

    private async Task CancelCurrentInstanceAsync()
    {
        if (CurrentInstance is null)
        {
            return;
        }

        await RunBusyAsync(async cancellationToken =>
        {
            await BundleApiClient.CancelWorkflowInstanceAsync(CurrentInstance.InstanceId, cancellationToken);
            CurrentInstance = await BundleApiClient.GetWorkflowInstanceAsync(CurrentInstance.InstanceId, cancellationToken);
            ExecutionErrorMessage = null;
            ExecutionSuccessMessage = $"Workflow instance {CurrentInstance.InstanceId} has been canceled.";
        });
    }

    private async Task RefreshWorkflowsAsync()
    {
        IsLoadingWorkflows = true;
        WorkflowsErrorMessage = null;

        using var cancellationSource = new CancellationTokenSource();
        try
        {
            var workflows = await BundleApiClient.GetRegisteredWorkflowsAsync(cancellationSource.Token);
            RegisteredWorkflows = workflows
                .OrderByDescending(x => x.RegisteredAt)
                .ThenBy(x => x.Name, StringComparer.OrdinalIgnoreCase)
                .ToList();

            if (RegisteredWorkflows.Count == 0)
            {
                SelectedWorkflowIndex = -1;
            }
            else if (SelectedWorkflowIndex < 0 || SelectedWorkflowIndex >= RegisteredWorkflows.Count)
            {
                SelectedWorkflowIndex = 0;
            }
        }
        catch (Exception ex)
        {
            WorkflowsErrorMessage = ex.Message;
        }
        finally
        {
            IsLoadingWorkflows = false;
        }
    }


    private WorkflowDefinitionMetadata? GetSelectedWorkflow()
    {
        if (SelectedWorkflowIndex < 0 || SelectedWorkflowIndex >= RegisteredWorkflows.Count)
        {
            return null;
        }

        return RegisteredWorkflows[SelectedWorkflowIndex];
    }

    private void StartWatching(Guid instanceId)
    {
        StopWatching();
        IsWatchingInstance = true;
        _watchCancellationSource = new CancellationTokenSource();
        _ = WatchInstanceAsync(instanceId, _watchCancellationSource.Token);
    }

    private async Task WatchInstanceAsync(Guid instanceId, CancellationToken cancellationToken)
    {
        try
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var instance = await BundleApiClient.GetWorkflowInstanceAsync(instanceId, cancellationToken);
                await InvokeAsync(() =>
                {
                    CurrentInstance = instance;
                    ExecutionErrorMessage = null;
                    StateHasChanged();
                });

                if (IsTerminalStatus(instance.Status))
                {
                    break;
                }

                await Task.Delay(TimeSpan.FromSeconds(2), cancellationToken);
            }
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            await InvokeAsync(() =>
            {
                ExecutionErrorMessage = $"Failed to refresh instance status: {ex.Message}";
                StateHasChanged();
            });
        }
        finally
        {
            await InvokeAsync(() =>
            {
                IsWatchingInstance = false;
                StateHasChanged();
            });
        }
    }

    private void StopWatching()
    {
        _watchCancellationSource?.Cancel();
        _watchCancellationSource?.Dispose();
        _watchCancellationSource = null;
        IsWatchingInstance = false;
    }

    private static bool IsTerminalStatus(string status)
    {
        return status.Equals("Succeeded", StringComparison.OrdinalIgnoreCase)
               || status.Equals("Failed", StringComparison.OrdinalIgnoreCase)
               || status.Equals("Canceled", StringComparison.OrdinalIgnoreCase);
    }

    private static string StatusClass(string status)
    {
        return status.ToLowerInvariant() switch
        {
            "running" => "running",
            "runnable" => "runnable",
            "waiting" => "waiting",
            "succeeded" => "succeeded",
            "failed" => "failed",
            "canceled" => "canceled",
            "aborted" => "aborted",
            _ => "pending"
        };
    }

    private static string FormatBytes(long size)
    {
        var units = new[] { "B", "KB", "MB", "GB" };
        var value = (double)size;
        var index = 0;

        while (value >= 1024 && index < units.Length - 1)
        {
            value /= 1024;
            index++;
        }

        return $"{value:0.##} {units[index]}";
    }
}
